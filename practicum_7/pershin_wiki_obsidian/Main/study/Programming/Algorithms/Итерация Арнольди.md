---
id: Итерация Арнольди
created_date: 03/05/2024
updated_date: 03/05/2024
type: термин
tags:
  - math
parent: "[[Численные методы]]"
---


> [! NOTE] ## Определение
> В численной линейной алгебре итерация Арнольди является алгоритмом [[Методы вычисления характеристического полинома| вычисления собственных значений]]. Арнольди находит приближение собственных значений и собственных векторов матриц общего вида(возможно не [[Эрмитово сопряжённая матрица|эрмитовой]]) с помощью построения ортонормированного базиса [[Подпростостранства Крылова| подпространства Крылова]]. 


### Алгоритм

Итерация Арнольди использует стабилизированый процесс [[Алгоритм Грама-Шмидта| Грама-Шмидта]] для получения последовательности ортонормированных векторов $q_1,q_2,q_3,\ldots$, называемых *векторами Арнольди*, таких, что для каждого $n$ векторы $q_1,\ldots,q_n$ являются базисом [[Подпростостранства Крылова| подпространства Крылова]] $\mathcal{K}_n.$ Алгоритм выглядит следующим образом:

1) Начать с произвольного вектора $q_1$ с нормой 1.

2) Повторить для $k=2,3,\ldots$
3) $q_k\leftarrow Aq_{k-1}$ 
	1)  for $j=1...k-1$ 
	2) $h_{j,k-1}\leftarrow q_{j}^{*}q_{k}$ 
	3) $q_k\leftarrow q_k-h_{j,k-1}q_j$
4) $h_{k,k-1}\leftarrow\|q_k\|$ 
5) $q_k\leftarrow\frac{q_k}{h_{k,k-1}}$

Цикл по $j$ проецирует компоненту $q_k$ на $q_1,\ldots,q_{k-1}.$ Это обеспечивает [[Ортогональная матрица| ортогональность]] всех построенных векторов.
Алгоритм останавливается, когда $q_k$ является нулевым вектором. Это происходит, когда минимальный многочлен матрицы $A$ будет степени $k.$
Каждый шаг цикла по $k$ производит одно умножение матрицы на вектор и около $4mk$ операций с дробными числами.
Ha языке программирования python:

```python
import numpy as np

def arnoldi_iteration(A, b, n: int):
    """Computes a basis of the (n + 1)-Krylov subspace of A: the space
    spanned by {b, Ab, ..., A^n b}.

    Arguments
      A: m × m array
      b: initial vector (length m)
      n: dimension of Krylov subspace, must be >= 1

    Returns
      Q: m x (n + 1) array, the columns are an orthonormal basis of the
        Krylov subspace.
      h: (n + 1) x n array, A on basis Q. It is upper Hessenberg.  
    """
    m = A.shape[0]
    h = np.zeros((n + 1, n))
    Q = np.zeros((m, n + 1))
    q = b / np.linalg.norm(b)  # Normalize the input vector
    Q[:, 0] = q  # Use it as the first Krylov vector

    for k in range(n):
        v = A.dot(q)  # Generate a new candidate vector
        for j in range(k + 1):  # Subtract the projections on previous vectors
            h[j, k] = np.dot(Q[:, j].conj(), v)
            v = v - h[j, k] * Q[:, j]

        h[k + 1, k] = np.linalg.norm(v)
        eps = 1e-12  # If v is shorter than this threshold it is the zero vector
        if h[k + 1, k] > eps:  # Add the produced vector to the list, unless
            q = v / h[k + 1, k]  # the zero vector is produced.
            Q[:, k + 1] = q
        else:  # If that happens, stop iterating.
            return Q, h
    return Q, h
```
## Ссылки на доп материал:
- https://ru.wikipedia.org/wiki/%D0%98%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%90%D1%80%D0%BD%D0%BE%D0%BB%D1%8C%D0%B4%D0%B8
- 


